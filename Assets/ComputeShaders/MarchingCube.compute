#pragma kernel CSMain
#include "Helper.compute"

struct Triangle {
    float3 a;
    float3 b;
    float3 c;
};

AppendStructuredBuffer<Triangle> triangles;
RWStructuredBuffer<float4> points;
int resolution;

int getIndex(int x, int y, int z) {
    return z * resolution * resolution + y * resolution + x;
}

float3 interpolate(float4 a, float4 b) {
    float3 p = a.xyz;
    float3 q = b.xyz;
    float t = a.w + b.w;
    return ((p+q)/2) + t;
}

[numthreads(8,8,8)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= resolution-1 || id.y >= resolution-1 || id.z >= resolution-1) {
        return;
    }

    float4 cube[8] = {
        points[getIndex(id.x, id.y, id.z)],
        points[getIndex(id.x+1, id.y, id.z)],
        points[getIndex(id.x, id.y+1, id.z)],
        points[getIndex(id.x+1, id.y+1, id.z)],
        points[getIndex(id.x, id.y, id.z+1)],
        points[getIndex(id.x+1, id.y, id.z+1)],
        points[getIndex(id.x, id.y+1, id.z+1)],
        points[getIndex(id.x+1, id.y+1, id.z+1)]
    };

    int cubeIndex = 0;
    // Calculate cube index
    if(cube[0].w != 0){cubeIndex += 1;}
    if(cube[1].w != 0){cubeIndex += 2;}
    if(cube[2].w != 0){cubeIndex += 4;}
    if(cube[3].w != 0){cubeIndex += 8;}
    if(cube[4].w != 0){cubeIndex += 16;}
    if(cube[5].w != 0){cubeIndex += 32;}
    if(cube[6].w != 0){cubeIndex += 64;}
    if(cube[7].w != 0){cubeIndex += 128;}

    if (cubeIndex != 0 && cubeIndex != 255) {

        for (int i = 0; triangleTable[cubeIndex][i] != -1; i += 3) {
            Triangle tri;
            tri.a = interpolate(cube[edgesTable[triangleTable[cubeIndex][i]][0]],cube[edgesTable[triangleTable[cubeIndex][i]][1]]);
            tri.b = interpolate(cube[edgesTable[triangleTable[cubeIndex][i+1]][0]],cube[edgesTable[triangleTable[cubeIndex][i+1]][1]]);
            tri.c = interpolate(cube[edgesTable[triangleTable[cubeIndex][i+2]][0]],cube[edgesTable[triangleTable[cubeIndex][i+2]][1]]);
            triangles.Append(tri);
        }
    }
}